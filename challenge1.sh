#!/bin/bash

# Creates a random string of numbers and alphabetic characters 
# with 15 characters of length.
# Uses a for loop with a range to append 20 lines to a file called randfile.txt every time the script runs
# The random string is generated by uuid file and formated using sed to eliminate dashes, cut to limit to 15 characteres, and tr
# to have some uppercase letters (BDF like in the example shown).
# I have no idea why the line always ends with a number 4

generateString () {
        ranstring=$(cat /proc/sys/kernel/random/uuid | sed 's/-/0/g' | cut -c-15 | tr [bdf] [BDF] >> ./randfile.txt)	
}    

if [ ! -e randfile.txt ]; then
	generateString
	echo "A file with random strings was created."
fi 

# Variable that saves the first part of stdout of the wc command with the -c option (number of bytes)
# I could have also used the stat command ( stat -c %s <path to file>) 
# I chose the wc option because I was familiar with the command and I had to research how to format the output to get only the number part 

filesize=$(wc -c randfile.txt | awk '{print $1}')

echo $filesize

# A while loop to control that the file size doesn't exceed 1048576 bytes or 1 MB (I got this number from a conversion table) and stops appending random strings when it reaches the limit)
# It  updates $filesize on every iteration so as to avoid an infinite loop (this part I felt was tricky)
# I could have used until file size is equal to 1048576 as well.
while [ $filesize -lt 1048576 ]
	do
		generateString
		echo The file randfile.txt has been appended with random strings.
		filesize=$(wc -c randfile.txt | awk '{print $1}')
	done

# I used the sort command because it is th only one I use to sort text. It seems that when a run it without any options the lines are sorted 
# from left to right and in this case each position from 0 to F (in hexadecimal ascending order).
# I could have sorted it reversely with the -r option. 
sort randfile.txt > ./sortedrandfile.txt

# Using the egrep command to search for patterns through regular expressions with the -v option to print only th lines that don't match the pattern.
wc -l sortedrandfile.txt

# It would work for a and A but in my randomly generated strings there are only lowercase a's.
linestrimmed=$(egrep "^[aA]" sortedrandfile.txt | wc -l)
echo ======================================================================================================================
echo "A total of $linestrimmed lines that start with a or A were removed from the file and saved in trimsortedrandfile.txt"
echo ======================================================================================================================   
egrep -v "^[aA]" sortedrandfile.txt > ./trimsortedrandfile.txt  
wc -l trimsortedrandfile.txt

# Wow! I think I've reached the end. Thanks!
